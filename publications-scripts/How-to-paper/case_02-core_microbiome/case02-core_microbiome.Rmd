---
title: "The UK Crop Microbiome Cryobank - How-to Guide: Case Study 2 - The Core Microbiome (Sugarbeet vs. Bulk Soil)"
author: "Payton Yau"
date: "14-03-2024"
output: md_document
---

# How-to Guide: Case Study 2 - The Core Microbiome (Sugarbeet vs. Bulk Soil)

To study rhizosphere microbiota, we identified the minimal microbiota interacting with a specific crop, sugar beet, in natural conditions across various soils. This approach helps understand real-world microbial interactions in the rhizosphere.

```{r packages, warning=FALSE, message=FALSE}
library("RColorBrewer")
library("phyloseq")
library("ggplot2")
```

```{r load, warning=FALSE, message=FALSE}
load("physeq.Sugarbeet.group.RData")
```

### Plotting the top 10 taxa at family level

Plotting the top 10 taxa at the family level offers a clear and concise overview of the microbial composition. This method not only highlights the most prevalent families in the sample but also simplifies complex microbiome data. It facilitates comparative analysis across different sample groups and allows for easy interpretation of trends and patterns. This approach enables quick identification of the most prevalent families within the corresponding sample groups.

```{r Top100_5, warning=FALSE, message=FALSE}
## Transform normalised ASVs to proportions 
proportions = transform_sample_counts(physeq.Sugarbeet.group, function(x) 100 * x/sum(x))

##  
Top10ASVs = names(sort(taxa_sums(proportions), TRUE)[1:21])
Taxtab10 = cbind(tax_table(proportions), Family10 = NA)
Taxtab10[Top10ASVs, "Family10"] <- as(tax_table(proportions)[Top10ASVs, "Family"], "character")
tax_table(proportions) <- tax_table(Taxtab10)

Rgsm10 = prune_taxa(Top10ASVs, proportions)

my_palette <- brewer.pal(n = 10, name = "Spectral")  

# plotting

p <- plot_bar(Rgsm10, "Soil.Location", fill = "Family") + coord_flip() +  
  ylab("Percentage of Sequences") + ylim(0, 20) + 
  geom_col() +  coord_flip() + 
  scale_fill_manual(values = my_palette) +
  labs(x = element_blank()) + 
  theme_classic() +   
  theme(text = element_text(size=15, colour = "black"), 
        axis.ticks = element_line(colour = "black", size = 1.25),
        axis.line = element_line(colour = 'black', size = 1.25),
        axis.text.x = element_text(angle=0, hjust=0.5, colour = "black", size = 13),
        axis.text.y = element_text(angle=0, hjust=0.5, colour = "black",size = 13),
        axis.title.y = element_text(color="black", size=15,face="bold"), 
        legend.position = "right", 
        legend.text = element_text(size = 9.5), 
        legend.key.height= unit(0.45, 'cm'),
        legend.key.width= unit(0.45, 'cm')
        )


# Create a plot for alpha diversity
# pdf(file = "Fig08A_TOP10.pdf", width = 8,height = 5)
print(p)
# Close the PDF device and save the plot to a file
# dev.off()

# Clean up by removing unnecessary objects
# rm(proportions, Top10ASVs, Taxtab10, Rgsm10, title)
```

### Upset plot using UpsetR

When it comes to representing sets visually, the go-to option is usually a Venn diagram. These diagrams work well when dealing with up to five sets, providing a clear visualisation. However, as the dataset expands, such as when dealing with five sets, deriving the desired insights from the diagram becomes more complex. As a result, considering an UpSet graph for data visualisation becomes an appealing choice. UpSet graphs offer a more streamlined way to display intersections and complements, particularly when dealing with larger datasets or multiple sets. This option ensures a more intuitive and informative representation of the data.

```{r UpsetR_Install, warning=FALSE, message=FALSE}
# BiocManager::install("microbiome")
library("microbiome")

# devtools::install_github("mikemc/speedyseq")
library("speedyseq")

# install.packages("UpSetR")
library("UpSetR")
# install.packages("plyr")
library("plyr")
# install.packages("reshape2")
library("reshape2")
# install.packages("RColorBrewer")
library("RColorBrewer")
# install.packages("dplyr")
library("dplyr")
```

```{r UpsetR, warning=FALSE, message=FALSE}
# Aggregate taxa at the genus level
B <- aggregate_taxa(physeq.Sugarbeet.group, "Genus", verbose = TRUE)

# Remove undesired genera
B2 <- subset_taxa(B, !get("Genus") %in% c("uncultured", "Unknown"))

# Remove unwanted taxon names
taxa_to_remove <- c("uncultured", "Unknown")
B2 <- subset_taxa(B, !get("Genus") %in% taxa_to_remove)

# Convert to tibble, rename columns, select relevant columns, group by Sample, and keep top 100 abundant ASVs
# Convert data to a tibble and perform necessary operations
D <- as_tibble(B2) %>%
  mutate(Sample = Soil.Location, ASV = .otu, Abundance = .abundance) %>%
  select(Sample, Abundance, Genus) %>%
  group_by(Sample) %>%
  filter(rank(desc(Abundance)) <= 100) %>% # Filter <= 100
  ungroup()

# Remove the Abundance column
D$Abundance <- NULL

# Rename the second column to "ASV"
names(D)[2] <- "ASV"
names(D)[1] <- "Soil.Location"

# Convert data from long to wide format
E <- dcast(D, ASV ~ Soil.Location)

# Define a binary function
binary_fun <- function(x) {
  x[is.na(x)] <- 0
  ifelse(x > 0, 1, 0)
}

col = brewer.pal(n = 9, name = "Set3")

# Apply the binary function to columns 2 to 10
temp_df <- apply(E[2:10], 2, binary_fun)
temp_df <- as.data.frame(temp_df)
rownames(temp_df) = E$ASV

# Create an UpSet plot
upset_plot <- upset(temp_df, 
                    sets = colnames(temp_df), 
                    sets.bar.color = (col),
                    order.by = "freq", 
                    empty.intersections = "on",
                    mainbar.y.label = "Counts by Pattern of Conditions", 
                    sets.x.label = "Counts by Condition",
                    matrix.color="blue", 
                    mb.ratio = c(0.6, 0.4),
                    point.size= 2.75,
                    line.size = 1.25, 
                    text.scale = 1.5
)

# Create a plot for alpha diversity
# Open a new PDF graphics device
# pdf(file = "Fig08B_UpSet.pdf", width=8,height=5)
# Print the ggtree plot
print(upset_plot)

# Close the PDF device and save the plot to a file
# dev.off()

# Clean up by removing unnecessary objects
rm(B, B2, D, E, binary_fun, upset_plot, physeq.Sugarbeet.group, upset_plot)
```

```{r Venn-install, warning=FALSE, message=FALSE}
# if (!require(devtools)) install.packages("devtools")
# devtools::install_github("yanlinlin82/ggvenn")

library(ggvenn)
```

```{r Venn, warning=FALSE, message=FALSE}
# Extract the rows where the value is 1 for each column
CL.YO <- rownames(temp_df)[temp_df$CL.YO == 1]
CY.YO <- rownames(temp_df)[temp_df$CY.YO == 1]
SC.SH <- rownames(temp_df)[temp_df$SC.SH == 1]
SL.SH <- rownames(temp_df)[temp_df$SL.SH == 1]

# Create a list with the extracted data
list_data <- list("CL.YO" = CL.YO, "CY.YO" = CY.YO, "SC.SH" = SC.SH, "SL.SH" = SL.SH)

# Use ggvenn to create the Venn diagram
Venn <- ggvenn(
  list_data, 
  fill_color = c("#0073C2FF", "#EFC000FF", "#868686FF", "#CD534CFF"),
  stroke_size = 0.5, set_name_size = 4
  )

# Open a new PDF graphics device
# pdf(file = "Fig08C_Venn.pdf", width=5,height=5)

# Print the Venn plot
print(Venn)

# Close the PDF device and save the plot to a file
# dev.off()
```


```{r sessionInfo, warning=FALSE, message=FALSE}
sessionInfo()
```
